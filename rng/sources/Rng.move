module RngAddress::Rng {
    use std::vector;
    use aptos_framework::timestamp;
    use std::hash;
    use aptos_std::table_with_length::TableWithLength;
    use aptos_std::table_with_length;
    use std::bcs;
    use std::signer;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use aptos_framework::coin::Coin;

    #[test_only]
    use aptos_framework::aptos_account::create_account;

    // TODO:
    // - Deploy on a network and test
    // - Add a client application to use the random numbers

    /// Address of the owner of the RNG
    const RNG_OWNER: address = @RngAddress;

    /// Conversion factor between seconds and microseconds
    const MICRO_CONVERSION_FACTOR: u64 = 1000000;

    /// Error codes
    const ENOT_MODULE_OWNER: u64 = 0;
    const EMODULE_NOT_INITIALIZED: u64 = 1;
    const EINVALID_INIT_PARAMS: u64 = 2;
    const EEMPTY_COMMITMENT: u64 = 3;
    const ECOMMITMENTS_ARE_IDENTICAL: u64 = 4;
    const EALREADY_COMMITTED: u64 = 5;
    const EALREADY_REVEALED_COMMITMENT: u64 = 6;
    const EINVALID_COMMITMENT_REVEAL: u64 = 7;
    const ENO_COMMITMENT_FOUND: u64 = 8;
    const ENOT_IN_COMMITMENT_PHASE: u64 = 9;
    const ENOT_IN_REVEAL_PHASE: u64 = 10;
    const ENOT_IN_REVEAL_BACKUP_PHASE: u64 = 11;
    const EPRIMARY_ENTROPY_NOT_REVEALED: u64 = 12;
    const EINVARIANT_VIOLATION: u64 = 13; // Indicates there must be a bug in the code!
    const ENOT_ENOUGH_MONEY_TO_COMMIT: u64 = 14;
    const ENO_COIN_CAPABILITY: u64 = 15;
    const ERANDOM_NUMBER_DOESNT_EXIST: u64 = 16;

    /// The distinct phases of the RNG contract
    const RNG_PHASE_COMMIT_ENTROPY: u8 = 0; // Users commit entropy
    const RNG_PHASE_REVEAL_ENTROPY: u8 = 1; // Users reveal (already committed) entropy
    const RNG_PHASE_REVEAL_BACKUP_ENTROPY: u8 = 2; // Users reveal (already committed) backup entropy

    /// The RNG that can be used to create random numbers on-chain
    struct RandomNumberGenerator has key {
        random_numbers: TableWithLength<u64, RandomNumberWithContext>, // The random number generated for the previous round

        round_number: u64, // The round number of the RNG (should be sequentially increasing)
        round_phase: u8, // The current phase of the round
        max_user_entropy_count: u64, // The max number of users who can add entropy to the RNG per round
        max_secs_per_phase: u64, // The max number of seconds per each phase of the RNG round
        commit_stake_amount: u64, // The amount of stake required in order to commit to entropy
        max_nums_to_retain: u64, // The max number of random numbers to retain internally
        phase_start_time: u64, // The starting timestamp of the current phase in the round

        committed_entropy_order: vector<address>, // The vector of addresses that committed entropies (in order) for the current round
        committed_entropy_table: TableWithLength<address, CommittedEntropy>, // The table of committed entropies for the current round
        revealed_entropy_table: TableWithLength<address, RevealedEntropy>, // The table of revealed entropies for the current round
        revealed_backup_entropy_table: TableWithLength<address, RevealedEntropy>, // The table of revealed backup entropies for the current round

        treasury: Coin<AptosCoin>, // The treasury holding all coins (e.g., as part of commitments)
    }

    /// Entropy committed to by a user (but not yet revealed)
    struct CommittedEntropy has copy, drop, store {
        hashed_entropy: vector<u8>, // The committed entropy, i.e., hashed_entropy = hash(bcs(entropy))
        backup_hashed_entropy: vector<u8>, // The backup committed entropy (in case someone doesn't reveal)
        timestamp: u64, // The time at which the commitment was made (defined by the validator proposing the block)
    }

    /// Entropy revealed by a user (used to calculate the final random number)
    struct RevealedEntropy has copy, drop, store {
        raw_entropy: u64, // The raw entropy revealed after the commitment
    }

    /// A random number that also specifies the security properties around generation
    struct RandomNumberWithContext has copy, drop, store {
        random_number: u64, // The random number generated by the RNG
        round_number: u64, // The round number at which the RNG generated this random number
        commit_stake_amount: u64, // The amount of AptosCoin required for each commit stake
        timestamp: u64, // The timestamp at which this random number was generated
        num_committers: u64, // The number of committers
        num_failed_reveals: u64, // The number of entropy entries that failed to reveal after committing
        num_failed_backup_reveals: u64, // The number of backup entropy entries that failed to reveal after committing
    }

    /// Inits the RNG when first published to the address of the sender
    fun init_module(sender: &signer) {
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 600;
        let commit_stake_amount = 100;
        let max_nums_to_retain = 50;

        init_module_inner(sender, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, max_nums_to_retain);
    }

    fun init_module_inner(sender: &signer, max_user_entropy_count: u64, max_secs_per_phase: u64, commit_stake_amount: u64, max_nums_to_retain: u64) {
        // Only the owner of the rng can initialize this module
        assert!(signer::address_of(sender) == RNG_OWNER, ENOT_MODULE_OWNER);

        // Verify the given parameters are valid
        assert!(max_user_entropy_count > 0, EINVALID_INIT_PARAMS);
        assert!(max_secs_per_phase > 0, EINVALID_INIT_PARAMS);
        assert!(commit_stake_amount > 0, EINVALID_INIT_PARAMS);
        assert!(max_nums_to_retain > 0, EINVALID_INIT_PARAMS);

        // Create the new RandomNumberGenerator
        move_to(
            sender,
            RandomNumberGenerator {
                random_numbers: table_with_length::new(),
                round_number: 0,
                round_phase: RNG_PHASE_COMMIT_ENTROPY,
                max_user_entropy_count,
                max_secs_per_phase,
                commit_stake_amount,
                max_nums_to_retain,
                phase_start_time: timestamp::now_microseconds(),
                committed_entropy_order: vector::empty<address>(),
                committed_entropy_table: table_with_length::new(),
                revealed_entropy_table: table_with_length::new(),
                revealed_backup_entropy_table: table_with_length::new(),
                treasury: coin::zero<AptosCoin>(),
            }
        );
    }

    /// Commits entropy to the current round of the RNG
    public entry fun commit_entropy(sender: &signer, hashed_entropy: vector<u8>, backup_hashed_entropy: vector<u8>) acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global_mut<RandomNumberGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for commitments
        assert!(rng.round_phase == RNG_PHASE_COMMIT_ENTROPY, ENOT_IN_COMMITMENT_PHASE);

        // If no-one has committed yet, we re-start the phase timer to allow periods of inactivity
        let current_time = timestamp::now_microseconds();
        if (vector::is_empty(&rng.committed_entropy_order)) {
            rng.phase_start_time = current_time;
        };

        // If enough time has elapsed to move to the next phase, we cannot commit the entropy
        if (current_phase_timed_out(rng, current_time)) {
            // TODO: what if no-one committed??
            abort ENOT_IN_COMMITMENT_PHASE
        };

        // Ensure the sender hasn't already sent a commitment
        let committer = signer::address_of(sender);
        assert!(!table_with_length::contains(&rng.committed_entropy_table, committer), EALREADY_COMMITTED);

        // Verify the hashed entropies are not empty
        assert!(hashed_entropy != vector::empty<u8>(), EEMPTY_COMMITMENT);
        assert!(backup_hashed_entropy != vector::empty<u8>(), EEMPTY_COMMITMENT);

        // Verify the hashed entropies are not equal
        assert!(hashed_entropy != backup_hashed_entropy, ECOMMITMENTS_ARE_IDENTICAL);

        // Withdraw the commit stake before committing the entropy
        withdraw_commit_stake(sender, rng);

        // Create and store a new entropy commitment for the sender
        let timestamp = timestamp::now_microseconds();
        let committed_entropy = CommittedEntropy {
            hashed_entropy,
            backup_hashed_entropy,
            timestamp,
        };
        table_with_length::add(&mut rng.committed_entropy_table, committer, committed_entropy);
        vector::push_back(&mut rng.committed_entropy_order, committer);

        // If we've hit the max number of users, move to the next phase
        if (vector::length(& rng.committed_entropy_order) >= rng.max_user_entropy_count) {
            move_to_reveal_phase(rng, current_time);
        }
    }

    /// Withdraws the commit stake from the sender (as part of making a commitment)
    /// and stores them in the treasury.
    fun withdraw_commit_stake(sender: &signer, rng: &mut RandomNumberGenerator) {
        let withdrawn_aptos_coins = coin::withdraw<AptosCoin>(sender, rng.commit_stake_amount);
        coin::merge(&mut rng.treasury, withdrawn_aptos_coins);
    }

    /// Reveals the entropy of the commitment made by the given account
    public entry fun reveal_entropy(sender: &signer, raw_entropy: u64) acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global_mut<RandomNumberGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for reveals
        let current_time = timestamp::now_microseconds();
        if ((rng.round_phase == RNG_PHASE_COMMIT_ENTROPY) && (current_phase_timed_out(rng, current_time))) {
            move_to_reveal_phase(rng, current_time);
        };
        assert!(rng.round_phase == RNG_PHASE_REVEAL_ENTROPY, ENOT_IN_REVEAL_PHASE);

        // If enough time has elapsed to move to the next phase, we cannot reveal the entropy
        if (current_phase_timed_out(rng, current_time)) {
            abort ENOT_IN_REVEAL_PHASE
        };

        // Verify the raw entropy hasn't already been revealed
        let committer = signer::address_of(sender);
        assert!(!table_with_length::contains(&rng.revealed_entropy_table, committer), EALREADY_REVEALED_COMMITMENT);

        // Find the commitment of the sender, verify the commitment, and update the raw entropies
        if (table_with_length::contains(&rng.committed_entropy_table, committer)) {
            // Verify the hash matches the raw entropy
            let hashed_entropy = table_with_length::borrow(&rng.committed_entropy_table, committer).hashed_entropy;
            verify_commitment(hashed_entropy, raw_entropy);

            // Insert the raw entropy into the revealed entropies table
            let revealed_entropy = RevealedEntropy {
                raw_entropy,
            };
            table_with_length::add(&mut rng.revealed_entropy_table, committer, revealed_entropy);
        } else {
            abort ENO_COMMITMENT_FOUND
        };

        // If all entropies have been revealed, we can generate the new random number and move to the next round
        let committed_order_length = vector::length(&rng.committed_entropy_order);
        let committed_table_length = table_with_length::length(&rng.committed_entropy_table);
        let revealed_table_length = table_with_length::length(&rng.revealed_entropy_table);
        if (committed_order_length == committed_table_length && committed_table_length == revealed_table_length) {
            generate_random_number_using_all_commitments(rng);
        }
    }

    /// Generates the new random number using all committed and revealed entropies.
    /// Stores the new random number in the generator and updates the RNG to the next round.
    ///
    /// Note: this function assumes the committed order, committed table and revealed table all have the
    /// same length and that all committers have revealed!
    fun generate_random_number_using_all_commitments(rng: &mut RandomNumberGenerator) {
        let commit_counter = 0;
        let num_commits = vector::length(&mut rng.committed_entropy_order);

        // Generate the random number
        let random_number = get_latest_random_number_without_context(rng);
        while (commit_counter < num_commits) {
            // Get the commitment timestamp and XOR it with the random number
            let committer = vector::borrow(&rng.committed_entropy_order, commit_counter);
            let commitment_timestamp = table_with_length::borrow(&rng.committed_entropy_table, *committer).timestamp;
            random_number = random_number ^ commitment_timestamp;

            // Get the raw entropy and XOR it with the random number
            let raw_entropy = table_with_length::borrow(&rng.revealed_entropy_table, *committer).raw_entropy;
            random_number = random_number ^ raw_entropy;

            // Unlock the user's stake
            let coins_to_release = coin::extract(&mut rng.treasury, rng.commit_stake_amount);
            coin::deposit(*committer, coins_to_release);

            commit_counter = commit_counter + 1;
        };

        // Store the newly generated random number
        update_and_store_random_number(rng, random_number, num_commits, 0, 0);

        // Clear the state of the RNG (i.e., commitments and reveals)
        clear_internal_state(rng);

        // Verify all data has been cleared
        verify_internal_state_is_clean(rng);
    }

    /// Reveals the backup entropy of the commitment made by the given account.
    ///
    /// Note that whichever accounts did not reveal successfully in the reveal phase
    /// cannot reveal backup entropy.
    public entry fun reveal_backup_entropy(sender: &signer, raw_entropy: u64) acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global_mut<RandomNumberGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for backup reveals
        let current_time = timestamp::now_microseconds();
        if ((rng.round_phase == RNG_PHASE_REVEAL_ENTROPY) && (current_phase_timed_out(rng, current_time))) {
            move_to_backup_reveal_phase(rng, current_time);
        };
        assert!(rng.round_phase == RNG_PHASE_REVEAL_BACKUP_ENTROPY, ENOT_IN_REVEAL_BACKUP_PHASE);

        // If enough time has elapsed, generate a random number using the
        // entropy that is available and move to the next round.
        let current_time = timestamp::now_microseconds();
        if (current_phase_timed_out(rng, current_time)) {
            generate_random_number_using_partial_reveals_and_backups(rng);
            abort ENOT_IN_REVEAL_BACKUP_PHASE
        };

        // Verify the sender is allowed to reveal backup entropy, i.e., it has already
        // revealed the primary entropy.
        let committer = signer::address_of(sender);
        assert!(table_with_length::contains(&rng.revealed_entropy_table, committer), EPRIMARY_ENTROPY_NOT_REVEALED);

        // Verify the raw backup entropy hasn't already been revealed
        assert!(!table_with_length::contains(&rng.revealed_backup_entropy_table, committer), EALREADY_REVEALED_COMMITMENT);

        // Find the backup commitment of the sender, verify the commitment, and update the backup entropies
        if (table_with_length::contains(&rng.committed_entropy_table, committer)) {
            // Verify the hash matches the raw backup entropy
            let hashed_entropy = table_with_length::borrow(&rng.committed_entropy_table, committer).backup_hashed_entropy;
            verify_commitment(hashed_entropy, raw_entropy);

            // Insert the raw entropy into the revealed backup entropies table
            let revealed_entropy = RevealedEntropy {
                raw_entropy,
            };
            table_with_length::add(&mut rng.revealed_backup_entropy_table, committer, revealed_entropy);
        } else {
            abort ENO_COMMITMENT_FOUND
        };

        // If all backup entropies have been revealed, we can generate the new random number and move to the next round
        let committed_order_length = vector::length(&rng.committed_entropy_order);
        let committed_table_length = table_with_length::length(&rng.committed_entropy_table);
        let revealed_table_length = table_with_length::length(&rng.revealed_entropy_table);
        let revealed_backup_table_length = table_with_length::length(&rng.revealed_backup_entropy_table);
        if (revealed_table_length == revealed_backup_table_length) {
            assert!(committed_order_length == committed_table_length, EINVARIANT_VIOLATION);
            assert!(committed_table_length > revealed_table_length, EINVARIANT_VIOLATION);
            generate_random_number_using_all_reveals_and_backups(rng);
        }
    }

    /// Generates the new random number using all revealed entropies (and backups).
    /// Stores the new random number in the generator and updates the RNG to the next round.
    ///
    /// Note: this function assumes the revealed table and revealed backup table have the
    /// same length, i.e., all parties who revealed honestly, did so in both phases.
    fun generate_random_number_using_all_reveals_and_backups(rng: &mut RandomNumberGenerator) {
        let num_committers = vector::length(& rng.committed_entropy_order);
        let committer_counter = 0;

        // Generate the random number
        let random_number = get_latest_random_number_without_context(rng);
        while (committer_counter < num_committers) {
            let committer = vector::borrow(&rng.committed_entropy_order, committer_counter);
            if (table_with_length::contains(&rng.revealed_entropy_table, *committer)
                && table_with_length::contains(&rng.revealed_backup_entropy_table, *committer) ) {
                // Get the commitment timestamp and XOR it with the random number
                let commitment_timestamp = table_with_length::borrow(&rng.committed_entropy_table, *committer).timestamp;
                random_number = random_number ^ commitment_timestamp;

                // Get the raw entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng.revealed_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;

                // Get the raw backup entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng.revealed_backup_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;

                // Unlock the user's stake
                let coins_to_release = coin::extract(&mut rng.treasury, rng.commit_stake_amount);
                coin::deposit(*committer, coins_to_release);
            };

            committer_counter = committer_counter + 1;
        };

        // Store the newly generated random number
        let num_entropies = table_with_length::length(&rng.revealed_entropy_table);
        let num_failed_reveals = num_committers - num_entropies;
        update_and_store_random_number(rng, random_number, num_committers, num_failed_reveals, 0);

        // Clear the state of the RNG (i.e., commitments and reveals)
        clear_internal_state(rng);

        // Verify all data has been cleared
        verify_internal_state_is_clean(rng);
    }

    /// Generates the new random number using all partially revealed entropies (and backups).
    /// Stores the new random number in the generator and updates the RNG to the next round.
    ///
    /// Note: this function assumes that the number of reveals is > the number of backup reveals.
    fun generate_random_number_using_partial_reveals_and_backups(rng: &mut RandomNumberGenerator) {
        let num_committers = vector::length(& rng.committed_entropy_order);
        let committer_counter = 0;

        // Generate the random number
        let random_number = get_latest_random_number_without_context(rng);
        while (committer_counter < num_committers) {
            let committer = vector::borrow(&rng.committed_entropy_order, committer_counter);
            if (table_with_length::contains(&rng.revealed_entropy_table, *committer)) {
                // Get the commitment timestamp and XOR it with the random number
                let commitment_timestamp = table_with_length::borrow(&rng.committed_entropy_table, *committer).timestamp;
                random_number = random_number ^ commitment_timestamp;

                // Get the raw entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng.revealed_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;
            };
            if (table_with_length::contains(&rng.revealed_backup_entropy_table, *committer)) {
                // Get the raw backup entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng.revealed_backup_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;
            };

            // Unlock the user's stake if they revealed in both phases (primary and backup)
            if (table_with_length::contains(&rng.revealed_entropy_table, *committer)
                && table_with_length::contains(&rng.revealed_backup_entropy_table, *committer)) {
                let coins_to_release = coin::extract(&mut rng.treasury, rng.commit_stake_amount);
                coin::deposit(*committer, coins_to_release);
            };

            committer_counter = committer_counter + 1;
        };

        // Store the newly generated random number
        let num_entropies = table_with_length::length(&rng.revealed_entropy_table);
        let num_failed_reveals = num_committers - num_entropies;
        let num_backup_entropies = table_with_length::length(&rng.revealed_backup_entropy_table);
        let num_failed_backup_reveals = num_entropies - num_backup_entropies;
        update_and_store_random_number(rng, random_number, num_committers, num_failed_reveals, num_failed_backup_reveals);

        // Clear the state of the RNG (i.e., commitments and reveals)
        clear_internal_state(rng);

        // Verify all data has been cleared
        verify_internal_state_is_clean(rng);
    }

    /// Updates the given RNG to move to the reveal phase
    fun move_to_reveal_phase(rng: &mut RandomNumberGenerator, current_time: u64) {
        rng.round_phase = RNG_PHASE_REVEAL_ENTROPY;
        rng.phase_start_time = current_time;
    }

    /// Updates the given RNG to move to the backup reveal phase
    fun move_to_backup_reveal_phase(rng: &mut RandomNumberGenerator, current_time: u64) {
        rng.round_phase = RNG_PHASE_REVEAL_BACKUP_ENTROPY;
        rng.phase_start_time = current_time;
    }

    /// Returns true iff the current phase of the RNG has timedout
    fun current_phase_timed_out(rng: &RandomNumberGenerator, current_time: u64): bool {
        (current_time - rng.phase_start_time) > (rng.max_secs_per_phase * MICRO_CONVERSION_FACTOR)
    }

    /// Fails if the given commitment and pre-image do not match
    fun verify_commitment(hashed_entropy: vector<u8>, raw_entropy: u64) {
        let raw_entropy_encoded = bcs::to_bytes(&raw_entropy);
        assert!(hash::sha3_256(raw_entropy_encoded) == hashed_entropy, EINVALID_COMMITMENT_REVEAL);
    }

    /// Updates and stores the given random number for the specified generator
    fun update_and_store_random_number(rng: &mut RandomNumberGenerator, random_number: u64, num_committers: u64, num_failed_reveals: u64, num_failed_backup_reveals: u64) {
        // Add context to the random number
        let timestamp = timestamp::now_microseconds();
        let random_number_with_context = RandomNumberWithContext {
            random_number,
            round_number: rng.round_number,
            commit_stake_amount: rng.commit_stake_amount,
            timestamp,
            num_committers,
            num_failed_reveals,
            num_failed_backup_reveals,
        };

        // Update the state of the RNG with the new random number
        if (rng.round_number >= rng.max_nums_to_retain) {
            // Keep the length of the table less than max_nums_to_retain
            let _ = table_with_length::remove(&mut rng.random_numbers, rng.round_number - rng.max_nums_to_retain);
        };
        table_with_length::add(&mut rng.random_numbers, rng.round_number, random_number_with_context);

        // Move to the next round
        rng.round_number = rng.round_number + 1;
        rng.round_phase = RNG_PHASE_COMMIT_ENTROPY;
        rng.phase_start_time = timestamp;
    }

    /// Clears the internal state of the RNG
    fun clear_internal_state(rng: &mut RandomNumberGenerator) {
        let commit_counter = 0;
        let num_commits = vector::length(&mut rng.committed_entropy_order);

        while (commit_counter < num_commits) {
            // Clear the commit and entropy data from all structures
            let committer = vector::remove(&mut rng.committed_entropy_order, 0); // TODO: Optimize!
            if (table_with_length::contains(&mut rng.committed_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng.committed_entropy_table, committer);
            };
            if (table_with_length::contains(&mut rng.revealed_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng.revealed_entropy_table, committer);
            };
            if (table_with_length::contains(&mut rng.revealed_backup_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng.revealed_backup_entropy_table, committer);
            };

            // Increment the entropy counter
            commit_counter = commit_counter + 1;
        };
    }

    /// Verifies that the internal state of the RNG is clean, i.e.,
    /// that all tables and vectors are empty.
    fun verify_internal_state_is_clean(rng: &mut RandomNumberGenerator) {
        assert!(vector::length(&rng.committed_entropy_order) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng.committed_entropy_table) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng.revealed_entropy_table) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng.revealed_backup_entropy_table) == 0, EINVARIANT_VIOLATION);
    }

    /// Updates the latest random number. A workaround for missing view functions.
    public entry fun update_latest_random_number(sender: &signer) acquires RandomNumberGenerator {
        let _ = get_latest_random_number(sender);
    }

    /// Returns the last generated random number. This is what clients (e.g., other
    /// modules are expected to call).
    public entry fun get_latest_random_number(sender: &signer): RandomNumberWithContext acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global_mut<RandomNumberGenerator>(RNG_OWNER);

        // If we've fallen back to the backup reveal phase, and enough time has
        // elapsed to move to the next round, update the RNG!
        let current_time = timestamp::now_microseconds();
        if ((rng.round_phase == RNG_PHASE_REVEAL_BACKUP_ENTROPY) && (current_phase_timed_out(rng, current_time))) {
            generate_random_number_using_partial_reveals_and_backups(rng);
        };

        // Get the random number
        if (rng.round_number == 0) {
            // No random number has been generated. Return an empty placeholder.
            RandomNumberWithContext {
                random_number: 0,
                round_number: 0,
                commit_stake_amount: 0,
                timestamp: 0,
                num_committers: 0,
                num_failed_reveals: 0,
                num_failed_backup_reveals: 0,
            }
        } else {
            get_random_number_for_round(sender, rng.round_number - 1)
        }
    }

    /// Returns the generated random number at the specified round. This is what clients (e.g., other
    /// modules are expected to call).
    public entry fun get_random_number_for_round(_sender: &signer, round_number: u64): RandomNumberWithContext acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global_mut<RandomNumberGenerator>(RNG_OWNER);

        // Verify the round number is valid
        assert!(rng.round_number > 0, ERANDOM_NUMBER_DOESNT_EXIST);
        assert!(round_number <= (rng.round_number - 1), ERANDOM_NUMBER_DOESNT_EXIST);
        if (rng.round_number > rng.max_nums_to_retain) {
            assert!(round_number >= (rng.round_number - rng.max_nums_to_retain), ERANDOM_NUMBER_DOESNT_EXIST);
        };

        // Get the random number
        *table_with_length::borrow(&rng.random_numbers, round_number)
    }

    /// Returns the latest random number without context
    fun get_latest_random_number_without_context(rng: &RandomNumberGenerator): u64 {
        if (rng.round_number == 0) {
            0 // No previous random number has been generated yet
        } else {
            table_with_length::borrow(&rng.random_numbers, rng.round_number - 1).random_number
        }
    }

    /// Returns the amount of AptosCoin held by the treasury
    fun get_treasury_value(_sender: &signer): u64 acquires RandomNumberGenerator {
        // Ensure the module has been initialized
        assert!(exists<RandomNumberGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng = borrow_global<RandomNumberGenerator>(RNG_OWNER);
        coin::value(&rng.treasury)
    }

    /// Test constants
    // TODO: can we clean this up?
    const EINSUFFICIENT_BALANCE: u64 = 65542;

    #[test(account = @0xC0FFEE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_MODULE_OWNER, location = Self)]
    fun test_init_not_owner(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 1, 10000, 1, 50);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_INIT_PARAMS, location = Self)]
    fun test_init_invalid_user_count(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 0, 10000, 1, 50);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_INIT_PARAMS, location = Self)]
    fun test_init_invalid_timeout(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 100, 0, 1, 50);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_INIT_PARAMS, location = Self)]
    fun test_init_invalid_max_nums(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 100, 1, 1, 0);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_commit(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Attempt to commit entropy
        let raw_entropy = 1010101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, hashed_entropy);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_reveal(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Attempt to reveal entropy
        reveal_entropy(&account, 754);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_reveal_backup(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Attempt to reveal backup entropy
        reveal_backup_entropy(&account, 754);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EEMPTY_COMMITMENT, location = Self)]
    fun test_empty_commitment(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 1, 10000, 1, 50);

        // Attempt to commit empty entropy
        commit_entropy(&account, vector::empty<u8>(), vector::empty<u8>());
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EEMPTY_COMMITMENT, location = Self)]
    fun test_empty_backup_commitment(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 1, 10000, 1, 50);

        // Attempt to commit empty backup entropy
        let raw_entropy = 19994;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, vector::empty<u8>());
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ECOMMITMENTS_ARE_IDENTICAL, location = Self)]
    fun test_identical_commitments(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        init_module_inner(&account, 1, 10000, 1, 50);

        // Attempt to commit identical entropy pairs
        let raw_entropy = 123;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, hashed_entropy);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_COMMITMENT_REVEAL, location = Self)]
    fun test_invalid_reveal(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&account));

        // Deposit into the sender account
        let account_balance = 1;
        coin::deposit(signer::address_of(&account), coin::mint(account_balance, &mint_cap));
        assert!(coin::balance<AptosCoin>(signer::address_of(&account)) == account_balance, 0);

        // Initialize the module
        let max_secs_per_phase = 10000;
        init_module_inner(&account, 1, max_secs_per_phase, account_balance, 50);
        assert!(get_treasury_value(&account) == 0, 0);

        // Commit some entropy
        let raw_entropy = 10101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 10102;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&account, hashed_entropy, hashed_backup_entropy);

        // Verify the treasury has the correct balance
        assert!(get_treasury_value(&account) == account_balance, 0);

        // All users have committed entropy, let's reveal an invalid entropy
        reveal_entropy(&account, raw_entropy + 1);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINSUFFICIENT_BALANCE, location = aptos_framework::coin)]
    fun test_invalid_reveal_not_enough_stake(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&account));

        // Deposit into the sender account
        let account_balance = 1;
        coin::deposit(signer::address_of(&account), coin::mint(account_balance, &mint_cap));
        assert!(coin::balance<AptosCoin>(signer::address_of(&account)) == account_balance, 0);

        // Initialize the module
        let max_secs_per_phase = 10000;
        init_module_inner(&account, 1, max_secs_per_phase, account_balance * 2, 50);

        // Commit some entropy
        let raw_entropy = 10101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 10102;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&account, hashed_entropy, hashed_backup_entropy);

        // All users have committed entropy, let's reveal an invalid entropy
        reveal_entropy(&account, raw_entropy + 1);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_COMMITMENT_REVEAL, location = Self)]
    fun test_invalid_reveal_multiple_users(aptos_framework: &signer, account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&account));

        // Deposit into the sender account
        let account_balance = 1;
        coin::deposit(signer::address_of(&account), coin::mint(account_balance, &mint_cap));
        assert!(coin::balance<AptosCoin>(signer::address_of(&account)) == account_balance, 0);

        // Initialize the module
        let max_secs_per_phase = 10000;
        init_module_inner(&account, 2, max_secs_per_phase, account_balance, 50);

        // Commit some entropy
        let raw_entropy = 10101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 10102;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&account, hashed_entropy, hashed_backup_entropy);

        // Elapse enough time to move us to the reveal phase
        timestamp::update_global_time_for_test(global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1);
        reveal_entropy(&account, raw_entropy + 1);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account = @0xC0FFEE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ERANDOM_NUMBER_DOESNT_EXIST, location = Self)]
    fun test_rng_happy_invalid_round_zero(aptos_framework: &signer, rng_account: signer, user_account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 1;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 15;
        let max_nums_to_retain = 5;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, max_nums_to_retain);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account));
        coin::deposit(signer::address_of(&user_account), coin::mint(1045632, &mint_cap));

        // Read and verify the generated random number at zero (this should fail!)
        let _ = get_random_number_for_round(&user_account, 0);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account = @0xC0FFEE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ERANDOM_NUMBER_DOESNT_EXIST, location = Self)]
    fun test_rng_happy_invalid_round_high(aptos_framework: &signer, rng_account: signer, user_account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 1;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 15;
        let max_nums_to_retain = 5;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, max_nums_to_retain);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account));
        coin::deposit(signer::address_of(&user_account), coin::mint(1045632, &mint_cap));

        // Read and verify the generated random number at round 10 (this should fail!)
        let _ = get_random_number_for_round(&user_account, 10);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    fun test_rng_happy_paths(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 15;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));

        // Deposit into the sender accounts
        let account_balance_1 = 10456;
        let account_balance_2 = 1323;
        coin::deposit(signer::address_of(&user_account_1), coin::mint(account_balance_1, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(account_balance_2, &mint_cap));
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_1)) == account_balance_1, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_2)) == account_balance_2, 0);

        // Read and verify the generated random number
        let previous_random_number = get_latest_random_number(&user_account_1);
        assert!(previous_random_number.random_number == 0, 0);
        assert!(previous_random_number.round_number == 0, 0);
        assert!(previous_random_number.timestamp == 0, 0);
        assert!(previous_random_number.num_committers == 0, 0);
        assert!(previous_random_number.num_failed_reveals == 0, 0);
        assert!(previous_random_number.num_failed_backup_reveals == 0, 0);

        // Generate and test several random number generations
        let generation_counter = 0;
        while (generation_counter < 10) {
            // Update the global timestamp
            let global_time_micros = global_time_micros + ((generation_counter + 1) * 1000);
            timestamp::update_global_time_for_test(global_time_micros);

            // Commit some entropy
            let raw_entropy_1 = generation_counter;
            let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
            let raw_backup_entropy_1 = generation_counter + 1;
            let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
            commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);
            std::debug::print(&raw_entropy_1);
            std::debug::print(&hashed_entropy_1);

            // Commit some entropy
            let raw_entropy_2 = 4567;
            let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
            let raw_backup_entropy_2 = 12334;
            let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
            commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

            // Reveal the entropy
            let new_global_timestamp = global_time_micros + 500;
            timestamp::update_global_time_for_test(new_global_timestamp);
            reveal_entropy(&user_account_1, raw_entropy_1);
            reveal_entropy(&user_account_2, raw_entropy_2);

            // Read the newly generated random number
            let random_number_with_context = get_latest_random_number(&rng_account);
            assert!(random_number_with_context.round_number == generation_counter, 0);
            assert!(random_number_with_context.timestamp == new_global_timestamp, 0);
            assert!(random_number_with_context.num_committers == 2, 0);
            assert!(random_number_with_context.num_failed_reveals == 0, 0);
            assert!(random_number_with_context.num_failed_backup_reveals == 0, 0);

            // Verify balances
            assert!(get_treasury_value(&user_account_2) == 0, 0);
            assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_1)) == account_balance_1, 0);
            assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_2)) == account_balance_2, 0);

            // Increment the generation counter
            generation_counter = generation_counter + 1;
        };

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
        assert!(false, 0);
    }

    #[test(rng_account = @RngAddress, user_account = @0xC0FFEE, aptos_framework = @aptos_framework)]
    fun test_rng_happy_paths_sequence(aptos_framework: &signer, rng_account: signer, user_account: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 123456;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 1;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 15;
        let max_nums_to_retain = 50;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, max_nums_to_retain);

        // Initialize the sender account
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account));
        coin::deposit(signer::address_of(&user_account), coin::mint(1045632, &mint_cap));

        // Generate and test several random number generations
        let generation_counter = 0;
        while (generation_counter < max_nums_to_retain) {
            // Update the global timestamp
            let global_time_micros = global_time_micros + ((generation_counter + 1) * 1000);
            timestamp::update_global_time_for_test(global_time_micros);

            // Commit some entropy
            let raw_entropy = 2345;
            let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
            let raw_backup_entropy = 12121;
            let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
            commit_entropy(&user_account, hashed_entropy, hashed_backup_entropy);

            // Reveal the entropy
            let new_global_timestamp = global_time_micros + 500;
            timestamp::update_global_time_for_test(new_global_timestamp);
            reveal_entropy(&user_account, raw_entropy);

            // Read the newly generated random number
            let random_number_with_context = get_random_number_for_round(&rng_account, generation_counter);
            assert!(random_number_with_context.round_number == generation_counter, 0);
            assert!(random_number_with_context.timestamp == new_global_timestamp, 0);
            assert!(random_number_with_context.num_committers == 1, 0);
            assert!(random_number_with_context.num_failed_reveals == 0, 0);
            assert!(random_number_with_context.num_failed_backup_reveals == 0, 0);

            // Increment the generation counter
            generation_counter = generation_counter + 1;
        };

        // Fetch the stored random numbers
        let fetch_counter = 0;
        while (fetch_counter < max_nums_to_retain) {
            // Read the newly generated random number
            let random_number_with_context = get_random_number_for_round(&rng_account, fetch_counter);
            assert!(random_number_with_context.round_number == fetch_counter, 0);
            assert!(random_number_with_context.num_committers == 1, 0);
            assert!(random_number_with_context.num_failed_reveals == 0, 0);
            assert!(random_number_with_context.num_failed_backup_reveals == 0, 0);

            // Increment the generation counter
            fetch_counter = fetch_counter + 1;
        };

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_IN_COMMITMENT_PHASE, location = Self)]
    fun test_rng_commit_phase_timeout(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 100;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, 1, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));

        // Deposit into the sender accounts
        coin::deposit(signer::address_of(&user_account_1), coin::mint(50, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(505, &mint_cap));

        // Commit some entropy for user 1
        let raw_entropy = 1111;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 12121;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&user_account_1, hashed_entropy, hashed_backup_entropy);

        // Elapse enough time so that we now move to the reveal phase
        timestamp::update_global_time_for_test(global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1);

        // Committing some entropy for user 2 should fail
        let raw_entropy = 99999;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&user_account_2, hashed_entropy, hashed_entropy);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_IN_REVEAL_PHASE, location = Self)]
    fun test_rng_reveal_phase_timeout(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 100;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, 1, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));

        // Deposit into the sender accounts
        coin::deposit(signer::address_of(&user_account_1), coin::mint(50, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(505, &mint_cap));

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 12121;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);

        // Commit some entropy for user 2
        let raw_entropy_2 = 0;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 12132;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

        // Elapse enough time so that we now move to the reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Reveal the entropy for user 1
        reveal_entropy(&user_account_1, raw_entropy_1);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Attempting to reveal the entropy for user 2 should fail
        reveal_entropy(&user_account_1, raw_entropy_2);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, user_account_3 = @0xAAAAA, aptos_framework = @aptos_framework)]
    fun test_rng_reveal_phase_timeout_all_backups(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer, user_account_3: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 3;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 10101;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));
        create_account(signer::address_of(&user_account_3));

        // Deposit into the sender accounts
        let account_balance_1 = 50000000;
        let account_balance_2 = 456784950;
        let account_balance_3 = 332452445;
        coin::deposit(signer::address_of(&user_account_1), coin::mint(account_balance_1, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(account_balance_2, &mint_cap));
        coin::deposit(signer::address_of(&user_account_3), coin::mint(account_balance_3, &mint_cap));

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 12121;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);

        // Commit some entropy for user 2
        let raw_entropy_2 = 0;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 12132;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

        // Commit some entropy for user 2
        let raw_entropy_3 = 12;
        let hashed_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_entropy_3));
        let raw_backup_entropy_3 = 12132;
        let hashed_backup_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_3));
        commit_entropy(&user_account_3, hashed_entropy_3, hashed_backup_entropy_3);

        // Reveal the entropy for user 1 and user 2
        reveal_entropy(&user_account_1, raw_entropy_1);
        reveal_entropy(&user_account_2, raw_entropy_2);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Reveal the backup entropy for user 1 and user 2
        reveal_backup_entropy(&user_account_2, raw_backup_entropy_2);
        reveal_backup_entropy(&user_account_1, raw_backup_entropy_1);

        // Verify a new random number has been generated
        let random_number_with_context = get_latest_random_number(&user_account_2);
        assert!(random_number_with_context.round_number == 0, 0);
        assert!(random_number_with_context.timestamp == global_time_micros, 0);
        assert!(random_number_with_context.num_committers == 3, 0);
        assert!(random_number_with_context.num_failed_reveals == 1, 0);
        assert!(random_number_with_context.num_failed_backup_reveals == 0, 0);

        // Verify all users were refunded (except 3)
        assert!(get_treasury_value(&user_account_2) == commit_stake_amount, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_1)) == account_balance_1, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_2)) == account_balance_2, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_3)) == account_balance_3 - commit_stake_amount, 0);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, user_account_3 = @0xAAAAA, aptos_framework = @aptos_framework)]
    fun test_rng_reveal_phase_timeout_some_backups(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer, user_account_3: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 3;
        let max_secs_per_phase = 100;
        let commit_stake_amount = 10101;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));
        create_account(signer::address_of(&user_account_3));

        // Deposit into the sender accounts
        let account_balance_1 = 101010101;
        let account_balance_2 = 33030303;
        let account_balance_3 = 2323232323;
        coin::deposit(signer::address_of(&user_account_1), coin::mint(account_balance_1, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(account_balance_2, &mint_cap));
        coin::deposit(signer::address_of(&user_account_3), coin::mint(account_balance_3, &mint_cap));

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 12121;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);

        // Commit some entropy for user 2
        let raw_entropy_2 = 0;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 12132;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

        // Commit some entropy for user 2
        let raw_entropy_3 = 12;
        let hashed_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_entropy_3));
        let raw_backup_entropy_3 = 12132;
        let hashed_backup_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_3));
        commit_entropy(&user_account_3, hashed_entropy_3, hashed_backup_entropy_3);

        // Reveal the entropy for user 1 and user 2
        reveal_entropy(&user_account_1, raw_entropy_1);
        reveal_entropy(&user_account_2, raw_entropy_2);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Reveal the backup entropy for user 2
        reveal_backup_entropy(&user_account_2, raw_backup_entropy_2);

        // Elapse enough time so that we now move to the next round
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Verify a new random number is now generated
        let random_number_with_context = get_latest_random_number(&user_account_2);
        assert!(random_number_with_context.round_number == 0, 0);
        assert!(random_number_with_context.timestamp == global_time_micros, 0);
        assert!(random_number_with_context.num_committers == 3, 0);
        assert!(random_number_with_context.num_failed_reveals == 1, 0);
        assert!(random_number_with_context.num_failed_backup_reveals == 1, 0);

        // Verify only user 2 was refunded
        assert!(get_treasury_value(&user_account_2) == commit_stake_amount * 2, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_1)) == account_balance_1 - commit_stake_amount, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_2)) == account_balance_2, 0);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_3)) == account_balance_3 - commit_stake_amount, 0);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EPRIMARY_ENTROPY_NOT_REVEALED, location = Self)]
    fun test_rng_backup_reveal_without_reveal(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 3;
        let max_secs_per_phase = 100;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, 1, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));

        // Deposit into the sender accounts
        let account_balance = 101;
        coin::deposit(signer::address_of(&user_account_1), coin::mint(account_balance, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(account_balance, &mint_cap));

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 12121;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);

        // Commit some entropy for user 2
        let raw_entropy_2 = 0;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 12132;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

        // Elapse enough time so that we now move to the reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Reveal the entropy for user 1
        reveal_entropy(&user_account_1, raw_entropy_1);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Attempting to reveal the backup entropy for user 2 should fail (it didn't reveal originally)
        reveal_backup_entropy(&user_account_2, raw_backup_entropy_2);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, user_account_3 = @0xEEFFEE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_IN_REVEAL_BACKUP_PHASE, location = Self)]
    fun test_rng_reveal_backup_phase_timeout(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer, user_account_3: signer) acquires RandomNumberGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_micros = 100000;
        timestamp::update_global_time_for_test(global_time_micros);

        // Initialize the module
        let max_user_entropy_count = 3;
        let max_secs_per_phase = 600;
        let commit_stake_amount = 3;
        init_module_inner(&rng_account, max_user_entropy_count, max_secs_per_phase, commit_stake_amount, 50);

        // Initialize the sender accounts
        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(aptos_framework);
        create_account(signer::address_of(&user_account_1));
        create_account(signer::address_of(&user_account_2));
        create_account(signer::address_of(&user_account_3));

        // Deposit into the sender accounts
        coin::deposit(signer::address_of(&user_account_1), coin::mint(50, &mint_cap));
        coin::deposit(signer::address_of(&user_account_2), coin::mint(3, &mint_cap));
        coin::deposit(signer::address_of(&user_account_3), coin::mint(9005, &mint_cap));

        // Verify an empty first random number
        let random_number_with_context = get_latest_random_number(&user_account_2);
        assert!(random_number_with_context.random_number == 0, 0);
        assert!(random_number_with_context.round_number == 0, 0);
        assert!(random_number_with_context.timestamp == 0, 0);
        assert!(random_number_with_context.num_committers == 0, 0);
        assert!(random_number_with_context.num_failed_reveals == 0, 0);
        assert!(random_number_with_context.num_failed_backup_reveals == 0, 0);

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 11111;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_1)) == 47, 0);

        // Commit some entropy for user 2
        let raw_entropy_2 = 2222;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 22222;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_2)) == 0, 0);

        // Commit some entropy for user 3
        let raw_entropy_3 = 3333;
        let hashed_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_entropy_3));
        let raw_backup_entropy_3 = 33333;
        let hashed_backup_entropy_3 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_3));
        commit_entropy(&user_account_3, hashed_entropy_3, hashed_backup_entropy_3);
        assert!(coin::balance<AptosCoin>(signer::address_of(&user_account_3)) == 9002, 0);

        // Verify balances
        assert!(get_treasury_value(&user_account_1) == 3 * commit_stake_amount, 0);

        // Reveal the entropy for user 1
        reveal_entropy(&user_account_1, raw_entropy_1);

        // Reveal the entropy for user 3
        reveal_entropy(&user_account_3, raw_entropy_3);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Reveal the backup entropy for user 1
        reveal_backup_entropy(&user_account_1, raw_backup_entropy_1);

        // Elapse enough time so that we now move to the next RNG round
        global_time_micros = global_time_micros + (max_secs_per_phase * MICRO_CONVERSION_FACTOR) + 1;
        timestamp::update_global_time_for_test(global_time_micros);

        // Read the newly generated random number
        let random_number_with_context = get_latest_random_number(&user_account_2);
        assert!(random_number_with_context.round_number == 0, 0);
        assert!(random_number_with_context.timestamp == global_time_micros, 0);
        assert!(random_number_with_context.num_committers == 3, 0);
        assert!(random_number_with_context.num_failed_reveals == 1, 0);
        assert!(random_number_with_context.num_failed_backup_reveals == 1, 0);

        // Reveal the backup entropy for user 3. This should fail as we've already moved into the commit phase
        reveal_backup_entropy(&user_account_3, raw_backup_entropy_3);

        // Drop the capabilities
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }
}
